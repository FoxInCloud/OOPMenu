*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="sfmenu.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS sfbar AS sfmenubase OF "sfmenu.vcx" 		&& A bar in a popup
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addbar		&& Adds a bar to the submenu popup for this bar
		*m: addbars		&& Add bars to the submenu popup for this bar
		*m: addseparatorbar		&& Adds a separator bar to the submenu popup for this bar
		*m: allow		&& Determine if the bar is enabled
		*m: click		&& Called when the bar is chosen
		*m: define		&& Defines the bar
		*m: evaluatevisible		&& Determines if the bar is visible or not
		*m: findbarposition		&& Finds where the bar should be placed
		*m: hide		&& Hides the bar
		*m: lmarked_assign
		*m: lvisible_assign
		*m: oimplementation_assign
		*m: refresh		&& Refreshes the bar
		*m: setenabled		&& Sets the Enabled property to the match the implementation object's
		*m: setvisible		&& Sets the Visible property to the match the implementation object's
		*m: show		&& Displays the bar
		*p: cactiveformmethod		&& The method of the active form to execute
		*p: cappobjectmethod		&& The method of the application object to execute
		*p: cappobjectname		&& The name of the variable containing the application object (only used if cAppObjectMethod is filled in)
		*p: cbarposition		&& A "before" or "after" bar number clause
		*p: ccaption		&& The caption for the bar
		*p: cinstancename		&& The complete object path to this object starting from the menu object
		*p: ckey		&& The hotkey for the bar
		*p: ckeytext		&& The text for the hotkey
		*p: cmenuclauses		&& Other clauses for bar
		*p: cmrubarclass		&& The class to use for the MRU bar
		*p: cmrubarlibrary		&& The library containing the class specified in cMRUBarClass
		*p: conclickcommand		&& The command to execute when the bar is clicked
		*p: cpicturefile		&& The file name for the picture to use
		*p: cpictureresource		&& The system menu bar name for the picture to use
		*p: cpopupname		&& The name of the popup this bar belongs to
		*p: cpopupnamethis		&& The name of the popup this bar uses for submenus
		*p: cskipfor		&& The SKIP FOR clause for the bar
		*p: cstatusbartext		&& The text displayed in the status bar when this bar is highlighted
		*p: csystembar		&& The name of the VFP system menu bar if this is one of those
		*p: ldefined		&& .T. if the menu bar for this object has been defined
		*p: lenabled		&& .T. if the bar is enabled
		*p: linvert		&& .T. to make this an inverted bar
		*p: lmarked		&& .T. if the bar is marked
		*p: lmru		&& .T. to add an MRU bar at the bottom of the submenu
		*p: lspecified		&& .T. if the bar number is specified at a certain position
		*p: lvisible		&& .T. if the bar should be visible
		*p: nbarnumber		&& The number of the bar
		*p: nseparatorbarcount		&& The number of separator bars in the menu
		*p: oimplementation		&& A reference to an implementation object
		*p: oparent		&& A reference to the parent for this bar
	*</DefinedPropArrayMethod>

	PROTECTED cpopupname,cpopupnamethis,ldefined,lspecified,nseparatorbarcount
	cactiveformmethod = 		&& The method of the active form to execute
	cappobjectmethod = 		&& The method of the application object to execute
	cappobjectname = oApp		&& The name of the variable containing the application object (only used if cAppObjectMethod is filled in)
	cbarposition = 		&& A "before" or "after" bar number clause
	ccaption = 		&& The caption for the bar
	cinstancename = 		&& The complete object path to this object starting from the menu object
	ckey = 		&& The hotkey for the bar
	ckeytext = 		&& The text for the hotkey
	cmenuclauses = 		&& Other clauses for bar
	cmrubarclass = SFMRUBar		&& The class to use for the MRU bar
	cmrubarlibrary = SFMenu.vcx		&& The library containing the class specified in cMRUBarClass
	conclickcommand = 		&& The command to execute when the bar is clicked
	cpicturefile = 		&& The file name for the picture to use
	cpictureresource = 		&& The system menu bar name for the picture to use
	cpopupname = 		&& The name of the popup this bar belongs to
	cpopupnamethis = 		&& The name of the popup this bar uses for submenus
	cskipfor = not This.Allow()		&& The SKIP FOR clause for the bar
	cstatusbartext = 		&& The text displayed in the status bar when this bar is highlighted
	csystembar = 		&& The name of the VFP system menu bar if this is one of those
	ldefined = .F.		&& .T. if the menu bar for this object has been defined
	lenabled = .T.		&& .T. if the bar is enabled
	linvert = .F.		&& .T. to make this an inverted bar
	lmarked = .F.		&& .T. if the bar is marked
	lmru = .F.		&& .T. to add an MRU bar at the bottom of the submenu
	lspecified = .F.		&& .T. if the bar number is specified at a certain position
	lvisible = .T.		&& .T. if the bar should be visible
	Name = "sfbar"
	nbarnumber = 0		&& The number of the bar
	nseparatorbarcount = 0		&& The number of separator bars in the menu
	oimplementation = .NULL.		&& A reference to an implementation object
	oparent = .NULL.		&& A reference to the parent for this bar
	_memberdata = <VFPData>
		<memberdata name="addbar" type="method" display="AddBar"/>
		<memberdata name="addbars" type="method" display="AddBars"/>
		<memberdata name="addseparatorbar" type="method" display="AddSeparatorBar"/>
		<memberdata name="allow" type="method" display="Allow" favorites="True"/>
		<memberdata name="cactiveformmethod" type="property" display="cActiveFormMethod" favorites="True"/>
		<memberdata name="cappobjectmethod" type="property" display="cAppObjectMethod" favorites="True"/>
		<memberdata name="cappobjectname" type="property" display="cAppObjectName"/>
		<memberdata name="cbarposition" type="property" display="cBarPosition"/>
		<memberdata name="ccaption" type="property" display="cCaption" favorites="True"/>
		<memberdata name="cinstancename" type="property" display="cInstanceName"/>
		<memberdata name="ckey" type="property" display="cKey" favorites="True"/>
		<memberdata name="ckeytext" type="property" display="cKeyText" favorites="True"/>
		<memberdata name="click" type="method" display="Click" favorites="True"/>
		<memberdata name="cmenuclauses" type="property" display="cMenuClauses" favorites="True"/>
		<memberdata name="conclickcommand" type="property" display="cOnClickCommand" favorites="True"/>
		<memberdata name="cpicturefile" type="property" display="cPictureFile" favorites="True"/>
		<memberdata name="cpictureresource" type="property" display="cPictureResource" favorites="True"/>
		<memberdata name="cpopupname" type="property" display="cPopupName"/>
		<memberdata name="cpopupnamethis" type="property" display="cPopupNameThis"/>
		<memberdata name="cskipfor" type="property" display="cSkipFor" favorites="True"/>
		<memberdata name="cstatusbartext" type="property" display="cStatusBarText" favorites="True"/>
		<memberdata name="csystembar" type="property" display="cSystemBar" favorites="True"/>
		<memberdata name="define" type="method" display="Define"/>
		<memberdata name="evaluatevisible" type="method" display="EvaluateVisible" favorites="True"/>
		<memberdata name="findbarposition" type="method" display="FindBarPosition"/>
		<memberdata name="hide" type="method" display="Hide"/>
		<memberdata name="ldefined" type="property" display="lDefined"/>
		<memberdata name="lenabled" type="property" display="lEnabled"/>
		<memberdata name="linvert" type="property" display="lInvert"/>
		<memberdata name="lmarked" type="property" display="lMarked"/>
		<memberdata name="lmarked_assign" type="method" display="lMarked_Assign"/>
		<memberdata name="lmru" type="property" display="lMRU"/>
		<memberdata name="lspecified" type="property" display="lSpecified"/>
		<memberdata name="lvisible" type="property" display="lVisible"/>
		<memberdata name="lvisible_assign" type="method" display="lVisible_Assign"/>
		<memberdata name="nbarnumber" type="property" display="nBarNumber"/>
		<memberdata name="nseparatorbarcount" type="property" display="nSeparatorBarCount"/>
		<memberdata name="refresh" type="method" display="Refresh"/>
		<memberdata name="show" type="method" display="Show"/>
		<memberdata name="init" type="event" favorites="True"/>
		<memberdata name="oparent" type="property" display="oParent"/>
		<memberdata name="oimplementation" type="property" display="oImplementation"/>
		<memberdata name="oimplementation_assign" type="method" display="oImplementation_Assign"/>
		<memberdata name="setenabled" type="method" display="SetEnabled"/>
		<memberdata name="setvisible" type="method" display="SetVisible"/>
		<memberdata name="cmrubarclass" type="property" display="cMRUBarClass"/>
		<memberdata name="cmrubarlibrary" type="property" display="cMRUBarLibrary"/>
		</VFPData>
	
	PROCEDURE addbar		&& Adds a bar to the submenu popup for this bar
		lparameters tcClass, ;
			tcLibrary, ;
			tcName, ;
			tnBarNumber
		local lnBarNumber, ;
			llSpecified, ;
			loBar
		with This
		
		* Create a bar number if one wasn't passed.
		
			if vartype(tnBarNumber) = 'N' and tnBarNumber <> 0
				lnBarNumber = tnBarNumber
				llSpecified = .T.
			else
				lnBarNumber = .Count + 1
			endif vartype(tnBarNumber) = 'N' ...
		
		* Create the object as a member.
		
			if '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
				loBar = createobject(tcClass, lnBarNumber, .cPopupNameThis, tcName, ;
					llSpecified)
			else
				loBar = newobject(tcClass, tcLibrary, '', lnBarNumber, ;
					.cPopupNameThis, tcName, llSpecified)
			endif '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
			loBar.oParent = This
			.AddProperty(tcName, loBar)
		
		* Add the bar to the collection.
		
			.Add(loBar, tcName)
		endwith
		return loBar
		
	ENDPROC

	PROTECTED PROCEDURE addbars		&& Add bars to the submenu popup for this bar
		* Abstract method
		
	ENDPROC

	PROCEDURE addseparatorbar		&& Adds a separator bar to the submenu popup for this bar
		local lcName, ;
			loBar
		with This
			.nSeparatorBarCount = .nSeparatorBarCount + 1
			lcName = 'Separator' + transform(.nSeparatorBarCount)
			loBar  = .AddBar('SFSeparatorBar', 'SFMenu.vcx', lcName)
		endwith
		return loBar
		
	ENDPROC

	PROCEDURE allow		&& Determine if the bar is enabled
		* Abstract method
		
	ENDPROC

	PROCEDURE click		&& Called when the bar is chosen
		local lcMethod, ;
			lnPos, ;
			lcPadPath, ;
			lcBarPath, ;
			lcCommand
		with This
			do case
		
		* We have an implementation object and we're suppose to use it for execution,
		* so call its Execute method.
		
				case vartype(.oImplementation) = 'O' and ;
					not .oImplementation.lNoExecute
					.oImplementation.Execute()
		
		* If a method of the application object was specified, call it.
		
				case not empty(.cAppObjectMethod)
					lcMethod = .cAppObjectMethod
					lnPos    = at('(', lcMethod)
					if lnPos > 0
						lcMethod = left(lcMethod, lnPos - 1)
					endif lnPos > 0
					if type(.cAppObjectName + '.Name') = 'C' and ;
						pemstatus(evaluate(.cAppObjectName), lcMethod, 5)
						evaluate(.cAppObjectName + '.' + .cAppObjectMethod + ;
							iif(lnPos = 0, '()', ''))
					endif type(.cAppObjectName + '.Name') = 'C' ...
		
		* If a method of the active form was specified, call it.
		
				case not empty(.cActiveFormMethod)
					lcMethod = .cActiveFormMethod
					lnPos    = at('(', lcMethod)
					if lnPos > 0
						lcMethod = left(lcMethod, lnPos - 1)
					endif lnPos > 0
					if type('_screen.ActiveForm.Name') = 'C' and ;
						pemstatus(_screen.ActiveForm, lcMethod, 5)
						evaluate('_screen.ActiveForm.' + .cActiveFormMethod + ;
							iif(lnPos = 0, '()', ''))
					endif type('_screen.ActiveForm.Name') = 'C' ...
		
		* If an command to execute was specified, call it.
		
				case not empty(.cOnClickCommand)
					lcPadPath = .oParent.cInstanceName + '.'
					lcBarPath = lcPadPath + .Name + '.'
					lcCommand = strtran(strtran(.cOnClickCommand, 'This.oParent.', ;
						lcPadPath), 'This.', lcBarPath)
					if chr(13) $ lcCommand
						execscript(lcCommand)
					else
						&lcCommand
					endif chr(13) $ lcCommand
			endcase
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE define		&& Defines the bar
		local lcPopupName, ;
			lcPadPath, ;
			lcBarPath, ;
			llSystemBar, ;
			lcBarNumber, ;
			lcSkipFor, ;
			lcBarPosition, ;
			lcBarName, ;
			lnI, ;
			loBar, ;
			lnBar, ;
			lcClauses, ;
			lcPopupNameThis
		with This
			if vartype(.oParent) = 'O'
				lcPopupName    = .cPopupName
				lcPadPath      = .oParent.cInstanceName + '.'
				.cInstanceName = lcPadPath + .Name
				lcBarPath      = .cInstanceName + '.'
		
		* Get the bar number based on whether we're a system bar or not.
		
				if empty(.cSystemBar)
					lcBarNumber = transform(.nBarNumber)
				else
					lcBarNumber = transform(evaluate(.cSystemBar))
					llSystemBar = .T.
				endif empty(.cSystemBar)
		
		* Create a default status bar text if we don't have one.
		
				if empty(.cStatusBarText)
					.cStatusBarText = strtran(strtran(.cCaption, '\<'), '\')
				endif empty(.cStatusBarText)
		
		* Set the SKIP FOR for the bar.
		
				lcSkipFor = 'not ' + lcBarPath + 'lEnabled'
				if not empty(.cSkipFor)
					lcSkipFor = lcSkipFor + ' or ' + ;
						strtran(strtran(.cSkipFor, 'This.oParent.', lcPadPath), ;
							'This.', lcBarPath)
				endif not empty(.cSkipFor)
		
		* If a bar position has been defined, it may have been defined by bar name
		* rather than number, so get the appropriate bar number.
		
				lcBarPosition = ''
				if not empty(.cBarPosition)
					lcBarName = alltrim(upper(substr(.cBarPosition, 7)))
					if val(lcBarName) = 0
						for lnI = 1 to .nBarNumber - 1
							loBar = .oParent.Item(lnI)
							do case
								case not upper(loBar.Name) == lcBarName
								case empty(loBar.cSystemBar)
									lcBarPosition = trim(left(.cBarPosition, 6)) + ;
										' ' + transform(loBar.nBarNumber)
									exit
								otherwise
									lcBarPosition = trim(left(.cBarPosition, 6)) + ;
										' ' + transform(evaluate(loBar.cSystemBar))
									exit
							endcase
						next lnI
					else
						lcBarPosition = .cBarPosition
					endif val(lcBarName) = 0
		
		* If the bar position wasn't defined, see if there's another bar in our
		* position. If so, we'll use the BEFORE clause to put ourselves before that
		* one. This is needed, for example, if you refresh a bar; it's removed from the
		* menu, then readded. Without the BEFORE clause, it would be added to the end
		* because we define popups with the RELATIVE clause.
		
				else
					try
						lnBar = getbar(lcPopupName, .nBarNumber)
					catch
						lnBar = .nBarNumber
					endtry
					if lnBar <> .nBarNumber
						lcBarPosition = 'before ' + transform(lnBar)
					endif lnBar <> .nBarNumber
				endif not empty(.cBarPosition)
		
		* Set the other clauses of the DEFINE BAR command.
		
				lcClauses = .cMenuClauses + iif(empty(.cMenuClauses), '', ' ') + ;
					lcBarPosition
				if not empty(.cKey)
					lcClauses = lcClauses + ' key ' + .cKey + ", '" + .cKeyText + "'"
				endif not empty(.cKey)
				if .lInvert
					lcClauses = lcClauses + ' invert'
				endif .lInvert
				do case
					case not empty(.cPictureResource)
						lcClauses = lcClauses + ' pictres ' + .cPictureResource
					case not empty(.cPicturefile)
						lcClauses = lcClauses + " picture '" + .cPicturefile + "'"
					case not empty(.cSystemBar)
						lcClauses = lcClauses + ' pictres ' + .cSystemBar
				endcase
		
		* Define the bar.
		
				define bar &lcBarNumber of &lcPopupName prompt .cCaption ;
					message .cStatusBarText skip for &lcSkipFor &lcClauses
		
		* Mark the bar if it's supposed to be.
		
				if .lMarked
					set mark of bar &lcBarNumber of &lcPopupName to .T.
				endif .lMarked
		
		* If this isn't a system bar, call the Click method when the bar's selected.
		
				if not llSystemBar
					on selection bar &lcBarNumber of &lcPopupName &lcBarPath.Click()
				endif not llSystemBar
		
		* If we have any bars in our submenu, create the popup for it.
		
				if .Count > 0
					lcPopupNameThis = .cPopupNameThis
					define popup (.cPopupNameThis) margin relative shadow ;
						color scheme 4
					on bar &lcBarNumber of &lcPopupName activate popup &lcPopupNameThis
		
		* Now add bars to the submenu.
		
					.AddBars()
		
		* If this is an MRU submenu, add an MRU bar at the end.
		
					if .lMRU
						.AddBar(.cMRUBarClass, .cMRUBarLibrary, 'MRUBar')
					endif .lMRU
				endif .Count > 0
		
		* Flag that the menu bar has been defined.
		
				.lDefined = .T.
			endif vartype(.oParent) = 'O'
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE evaluatevisible		&& Determines if the bar is visible or not
		* Abstract method.
		
		if vartype(This.oImplementation) = 'O'
			return This.oImplementation.lVisible
		else
			return This.lVisible
		endif Vartype(This.oImplementation) = 'O'
		
	ENDPROC

	PROTECTED PROCEDURE findbarposition		&& Finds where the bar should be placed
		local lnBar, ;
			loBar, ;
			lcBarNumber, ;
			llFoundBar
		with This
		
		* We'll only do this if we don't already have a bar position.
		
			if empty(.cBarPosition)
		
		* See if there are any bars before this one that are currently visible.
		
				for lnBar = .nBarNumber - 1 to 1 step -1
					loBar = .oParent.Item(lnBar)
					if vartype(loBar) = 'O' and loBar.lVisible
						if empty(loBar.cSystemBar)
							lcBarNumber = transform(loBar.nBarNumber)
						else
							lcBarNumber = transform(evaluate(loBar.cSystemBar))
						endif empty(loBar.cSystemBar)
						.cBarPosition = 'after ' + lcBarNumber
						llFoundBar    = .T.
						exit
					endif vartype(loBar) = 'O' ...
				next lnBar
		
		* If we haven't found a bar to place this one after, see if there's one we can
		* place this before.
		
				if not llFoundBar
					for lnBar = .nBarNumber + 1 to .oParent.Count
						loBar = .oParent.Item(lnBar)
						if vartype(loBar) = 'O' and loBar.lVisible
							if empty(loBar.cSystemBar)
								lcBarNumber = transform(loBar.nBarNumber)
							else
								lcBarNumber = transform(evaluate(loBar.cSystemBar))
							endif empty(loBar.cSystemBar)
							.cBarPosition = 'before ' + lcBarNumber
							exit
						endif vartype(loBar) = 'O' ...
					next lnBar
				endif not llFoundBar
			endif empty(.cBarPosition)
		endwith
		
	ENDPROC

	PROCEDURE hide		&& Hides the bar
		local lnI, ;
			lcBarNumber, ;
			lcPopupName, ;
			lcPopupNameThis
		with This
			if .lDefined
		
		* Hide any bars in the submenu if there is one.
		
				for lnI = 1 to .Count
					loBar = .Item(lnI)
					loBar.Hide()
				next lnI
		
		* Hide the bar by releasing it.
		
				if empty(.cSystemBar)
					lcBarNumber = transform(.nBarNumber)
				else
					lcBarNumber = transform(evaluate(.cSystemBar))
				endif empty(.cSystemBar)
				lcPopupName = .cPopupName
				release bar &lcBarNumber of &lcPopupName
			endif .lDefined
		
		* Release our submenu popup if it exists.
		
			lcPopupNameThis = .cPopupNameThis
			if popup(lcPopupNameThis)
				release popup &lcPopupNameThis
			endif popup(lcPopupNameThis)
			.lDefined = .F.
		endwith
		
	ENDPROC

	PROCEDURE Init
		lparameters tnBarNumber, ;
			tcPopupName, ;
			tcName, ;
			tlSpecified
		with This
			.nBarNumber = tnBarNumber
			.cPopupName = tcPopupName
			.lSpecified = tlSpecified
			.lVisible   = .EvaluateVisible()
		
		* If a name was specified, use it.
		
			if vartype(tcName) = 'C' and not empty(tcName)
				.Name = tcName
			endif vartype(tcName) = 'C' ...
		
		* Define the popup for this bar.
		
			if empty(.cPopupNameThis)
				.cPopupNameThis = .Name
			endif empty(.cPopupNameThis)
		endwith
		
	ENDPROC

	PROCEDURE lmarked_assign
		lparameters tlValue
		local lcSetting, ;
			lcBarNumber, ;
			lcPopupName
		with This
			assert vartype(tlValue) = 'L'
			lcSetting = iif(tlValue, '.T.', '.F.')
			.lMarked  = tlValue
			if empty(.cSystemBar)
				lcBarNumber = transform(.nBarNumber)
			else
				lcBarNumber = transform(evaluate(.cSystemBar))
			endif empty(.cSystemBar)
			lcPopupname = .cPopupName
			set mark of bar &lcBarNumber of &lcPopupName to &lcSetting
		endwith
		
	ENDPROC

	PROCEDURE lvisible_assign
		lparameters tlValue
		assert vartype(tlValue) = 'L'
		with This
			if tlValue <> .lVisible
				.lVisible   = tlValue
				.lSpecified = .T.	&& so when we show it, it appears in correct place
				do case
					case .CalledFromThisClass()
					case tlValue
						.Show()
					otherwise
						.Hide()
				endcase
		
		* If this isn't a separator bar, call AdjustSeparators to avoid consecutive
		* separator bars.
		
				if lower(.Class) <> 'sfseparatorbar'
					.oParent.AdjustSeparators()
				endif lower(.Class) <> 'sfseparatorbar'
			endif tlValue <> .lVisible
		endwith
		
	ENDPROC

	PROCEDURE oimplementation_assign
		* Set a reference to an implementation object and bind to changes to its
		* lVisible and lEnabled properties.
		
		lparameters toObject
		if vartype(toObject) = 'O'
			This.oImplementation = toObject
			bindevent(This.oImplementation, 'lVisible', This, 'SetVisible', 1)
			bindevent(This.oImplementation, 'lEnabled', This, 'SetEnabled', 1)
		endif vartype(toObject) = 'O'
		
	ENDPROC

	PROCEDURE refresh		&& Refreshes the bar
		* Refresh the bar by hiding it, re-evaluating lVisible, and showing it again.
		
		with This
			.Hide()
			.lVisible = .EvaluateVisible()
			if .lVisible
				.Show()
			endif .lVisible
		endwith
		
	ENDPROC

	PROCEDURE releasemembers
		* Hide the bar by releasing it and nuke our own parent reference.
		
		local lnI, ;
			loBar
		This.Hide()
		dodefault()
		This.oParent = .NULL.
		
		* Unbind from and nuke our implementation object.
		
		if vartype(This.oImplementation) = 'O'
			unbindevents(This.oImplementation)
			This.oImplementation = .NULL.
		endif vartype(This.oImplementation) = 'O'
		
	ENDPROC

	PROCEDURE setenabled		&& Sets the Enabled property to the match the implementation object's
		if vartype(This.oImplementation) = 'O'
			This.lEnabled = This.oImplementation.lEnabled
		endif vartype(This.oImplementation) = 'O'
		
	ENDPROC

	PROCEDURE setvisible		&& Sets the Visible property to the match the implementation object's
		if vartype(This.oImplementation) = 'O'
			This.lVisible = This.oImplementation.lVisible
		endif vartype(This.oImplementation) = 'O'
		
	ENDPROC

	PROCEDURE show		&& Displays the bar
		* If we're supposed to, call FindBarPosition to see where the bar should go,
		* then define it.
		
		local lnI, ;
			loBar
		with This
			if .lVisible and not .lDefined
				if .lSpecified or .lInvert
					.FindBarPosition()
				endif .lSpecified ...
				.Define()
			endif .lVisible ...
		
		* Display any bars in our submenu if there is one.
		
			for lnI = 1 to .Count
				loBar = .Item(lnI)
				if loBar.lInvert
					loBar.Hide()
				else
					loBar.Show()
				endif loBar.lInvert
			next lnI
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfeditpad AS sfpad OF "sfmenu.vcx" 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	ccaption = \<Edit
	ckey = ALT+E
	cpopupname = _medit
	cstatusbartext = Edit text
	Name = "sfeditpad"
	
	PROCEDURE addbars		&& Add bars to the submenu popup for this bar
		with This
			.AddBar('SFBar', 'SFMenu.vcx', 'EditUndo')
			with .EditUndo
				.cCaption       = '\<Undo'
				.cKey           = 'CTRL+Z'
				.cKeyText       = 'Ctrl+Z'
				.cStatusBarText = 'Reverse the most recent edit action'
				.cSystemBar     = '_med_undo'
				.cPictureFile   = 'undoxpsmall.bmp'
			endwith
		
			.AddBar('SFBar', 'SFMenu.vcx', 'EditRedo')
			with .EditRedo
				.cCaption       = '\<Redo'
				.cKey           = 'CTRL+R'
				.cKeyText       = 'Ctrl+R'
				.cStatusBarText = 'Repeat the action previously reversed with Undo'
				.cSystemBar     = '_med_redo'
				.cPictureFile   = 'redoxpsmall.bmp'
			endwith
		
			.AddSeparatorBar()
		
			.AddBar('SFBar', 'SFMenu.vcx', 'EditCut')
			with .EditCut
				.cCaption       = 'Cu\<t'
				.cKey           = 'CTRL+X'
				.cKeyText       = 'Ctrl+X'
				.cStatusBarText = 'Remove the selection and put it on the clipboard'
				.cSystemBar     = '_med_cut'
				.cPictureFile   = 'cutxpsmall.bmp'
			endwith
		
			.AddBar('SFBar', 'SFMenu.vcx', 'EditCopy')
			with .EditCopy
				.cCaption       = '\<Copy'
				.cKey           = 'CTRL+C'
				.cKeyText       = 'Ctrl+C'
				.cStatusBarText = 'Copy the selection and put it on the clipboard'
				.cSystemBar     = '_med_copy'
				.cPictureFile   = 'copyxpsmall.bmp'
			endwith
		
			.AddBar('SFBar', 'SFMenu.vcx', 'EditPaste')
			with .EditPaste
				.cCaption       = '\<Paste'
				.cKey           = 'CTRL+V'
				.cKeyText       = 'Ctrl+V'
				.cStatusBarText = 'Paste the contents of the clipboard at the ' + ;
					'insertion point'
				.cSystemBar     = '_med_paste'
				.cPictureFile   = 'pastexpsmall.bmp'
			endwith
		
			.AddBar('SFBar', 'SFMenu.vcx', 'EditClear')
			with .EditClear
				.cCaption       = 'Clear'
				.cStatusBarText = 'Erase the selection'
				.cSystemBar     = '_med_clear'
				.cSkipFor       = 'empty(wontop())'
			endwith
		
			.AddSeparatorBar()
		
			.AddBar('SFBar', 'SFMenu.vcx', 'EditSelectAll')
			with .EditSelectAll
				.cCaption       = 'Select \<All'
				.cKey           = 'CTRL+A'
				.cKeyText       = 'Ctrl+A'
				.cStatusBarText = 'Select all lines of text in the current field'
				.cSystemBar     = '_med_slcta'
			endwith
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfhelptopicsbar AS sfbar OF "sfmenu.vcx" 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	ccaption = \<Help Topics
	ckey = F1
	ckeytext = F1
	cpicturefile = helpxpsmall.bmp
	cstatusbartext = Display Help table of contents
	csystembar = _mst_hpsch
	Name = "sfhelptopicsbar"

ENDDEFINE

DEFINE CLASS sfmenu AS sfmenubase OF "sfmenu.vcx" 		&& A menu
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addpad		&& Adds a pad to the menu
		*m: cinstancename_assign
		*m: definemenu		&& Defines the desired pads in the menu
		*m: refresh		&& Refreshes the display of the menu.
		*m: show		&& Displays the menu.
		*p: cformname		&& The name of a top-level form for the menu to be placed into
		*p: cinstancename		&& The name of the variable containing the reference for this object
		*p: cmenuname		&& The name of the menu
	*</DefinedPropArrayMethod>

	cformname = 		&& The name of a top-level form for the menu to be placed into
	cinstancename = 		&& The name of the variable containing the reference for this object
	cmenuname = _msysmenu		&& The name of the menu
	Name = "sfmenu"
	_memberdata = <VFPData>
		<memberdata name="addpad" type="method" display="AddPad"/>
		<memberdata name="cinstancename" type="property" display="cInstanceName"/>
		<memberdata name="cinstancename_assign" type="method" display="cInstanceName_Assign"/>
		<memberdata name="definemenu" type="method" display="DefineMenu"/>
		<memberdata name="refresh" type="method" display="Refresh"/>
		<memberdata name="show" type="method" display="Show"/>
		<memberdata name="cformname" type="property" display="cFormName"/>
		<memberdata name="cmenuname" type="property" display="cMenuName"/>
		</VFPData>
	
	PROCEDURE addpad		&& Adds a pad to the menu
		lparameters tcClass, ;
			tcLibrary, ;
			tcName
		local loPad, ;
			lnCount, ;
			loOtherPad
		with This
		
		* Add a pad of the desired class and name to the menu.
		
			if '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
				loPad = createobject(tcClass, tcName)
			else
				loPad = newobject(tcClass, tcLibrary, '', tcName)
			endif '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
			loPad.oParent = This
			.AddProperty(tcName, loPad)
		
		* Add the pad to the collection.
		
			.Add(loPad, tcName)
			lnCount = .Count
			do case
		
		* If this is the second item in the menu, tell the first item to display BEFORE
		* this item and this item to display AFTER that item.
		
				case lnCount = 2
					loOtherPad = .Item(1)
					loOtherPad.cPadPosition = 'before ' + tcName
					loPad.cPadPosition = 'after ' + loOtherPad.Name
		
		* If there are more than 2 items in the menu, this item will be displayed AFTER
		* the previous one.
		
				case lnCount > 2
					loOtherPad = .Item(lnCount - 1)
					loPad.cPadPosition = 'after ' + loOtherPad.Name
			endcase
		endwith
		return loPad
		
	ENDPROC

	PROCEDURE cinstancename_assign
		lparameters tuValue
		if This.CalledFromThisClass()
			This.cInstanceName = tuValue
		else
			error 1743, 'cInstanceName'
		endif This.CalledFromThisClass()
		
	ENDPROC

	PROTECTED PROCEDURE definemenu		&& Defines the desired pads in the menu
		* Abstract method
		
	ENDPROC

	PROCEDURE Init
		* Save the name of the variable or property we're being instantiated into in
		* cInstanceName. We need this so we can reference the object path from a bar
		* all the way up to the menu properly.
		
		lparameter tcInstanceName
		This.cInstanceName = tcInstanceName
		
	ENDPROC

	PROCEDURE refresh		&& Refreshes the display of the menu.
		* Refresh the menu by refreshing all pads and then activating it.
		
		local lnI
		with This
			for lnI = 1 to .Count
				loPad = .Item(lnI)
				loPad.Refresh()
			next lnI
			activate menu (.cMenuName) nowait
		endwith
		
	ENDPROC

	PROCEDURE releasemembers
		* Clean up the menu. 
		
		dodefault()
		set sysmenu automatic
		set sysmenu off
		set sysmenu to
		set sysmenu to default
		set sysmenu on
		
	ENDPROC

	PROCEDURE show		&& Displays the menu.
		local lnI, ;
			loPad
		with This
		
		* If we're putting the menu in a top-level form, set cMenuName and define the
		* menu in the specified form. Otherwise, clear the old menu.
		
			if empty(.cFormName) 
		    	set sysmenu to
			else 
				if .cMenuName = '_msysmenu'
					.cMenuName = sys(2015)
				endif .cMenuName = '_msysmenu'
				define menu (.cMenuName) bar in (.cFormName)
			endif empty(.cFormName) 
		
		* Define the menu if it hasn't already been.
		
			if .Count = 0
				.DefineMenu()
			endif .Count = 0
		
		* Show all the pads.
		
			for lnI = 1 to .Count
				loPad = .Item(lnI)
				loPad.Show()
			next lnI
		
		* Display the menu.
		
			set sysmenu automatic
			activate menu (.cMenuName) nowait
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfmenubase AS collection 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: calledfromthisclass		&& Return .T. if the method was called from this class
		*m: cleanup		&& Performs clean up task when the object is destroyed
		*m: release		&& Releases this object
		*m: releasemembers		&& Releases all member objects
		*p: cversion		&& The release date in the form YYYY.MM.DD
		*p: lrelease		&& .T. if the object is in the process of being destroyed
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED lrelease
	cversion = 2008.02.07		&& The release date in the form YYYY.MM.DD
	Height = 23
	lrelease = .F.		&& .T. if the object is in the process of being destroyed
	Name = "sfmenubase"
	Width = 23
	_memberdata = <VFPData>
		<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
		<memberdata name="cleanup" type="method" display="Cleanup"/>
		<memberdata name="lrelease" type="property" display="lRelease"/>
		<memberdata name="releasemembers" type="method" display="ReleaseMembers"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="cversion" type="property" display="cVersion"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROTECTED PROCEDURE calledfromthisclass		&& Return .T. if the method was called from this class
		local lnLevel, ;
			lcProgram, ;
			lcObject, ;
			loParent, ;
			laClasses[1], ;
			lnClasses, ;
			lnI, ;
			llReturn, ;
			lcThisName
		
		* Get the name of the program that called us, and get the object name from it.
		* Set loParent to our parent if there is one.
		
		lnLevel   = program(-1)
		lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
		lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
		loParent  = iif(type('This.Parent') = 'O', This.Parent, .NULL.)
		
		* Check our class hierarchy to see if we were called from ourselves or an
		* ancester method.
		
		lnClasses = aclass(laClasses, This)
		for lnI = 1 to lnClasses
			if lcObject == upper(laClasses[lnI])
				llReturn = .T.
				exit
			endif lcObject == upper(laClasses[lnI])
		next lnI
		
		* If we didn't come from ourselves or an ancestor and we have a parent, our
		* name may not match our class, so check the containership hierarchy.
		
		if not llReturn and not isnull(loParent)
			lcThisName = This.Name
			do while vartype(loParent) = 'O'
				lcThisName = loParent.Name + '.' + lcThisName
				loParent   = iif(type('loParent.Parent') = 'O', loParent.Parent, ;
					.NULL.)
			enddo while vartype(loParent) = 'O'
			llReturn = upper(lcObject) == upper(lcThisName)
		endif not llReturn ...
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE cleanup		&& Performs clean up task when the object is destroyed
		* Perform cleanup tasks. Note the avoidance of "with This" in this code to
		* prevent potential problems with dangling object references.
		
		if This.lRelease
			return
		endif This.lRelease
		This.lRelease = .T.
		This.ReleaseMembers()
		
	ENDPROC

	PROCEDURE Destroy
		* Cleanup as the object is destroyed.
		
		This.Cleanup()
		
	ENDPROC

	PROCEDURE Error
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			lcError, ;
			lcReturn, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError     = .oException.ErrorNo
				lcMethod    = .oException.Procedure
				lnLine      = .oException.LineNo
				lcSource    = .oException.LineContents
				laError[1]  = .oException.ErrorNo
				laError[2]  = .oException.Message
				laError[3]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
		if not empty(on('ERROR'))
			lcError = upper(on('ERROR'))
			lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
			lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
			lcError = strtran(lcError, ',ERROR()',  ',lnError')
			lcError = strtran(lcError, ' ERROR()',  ' lnError')
			lcError = strtran(lcError, 'LINENO()',  'lnLine')
			lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
			lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
			if left(lcError, 3) = 'DO ' or '=' $ lcError
				&lcError
				lcReturn = 'Continue'
			else
				lcReturn = &lcError
			endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
		else
			lcSource  = message(1)
			lcMessage = 'Error #: ' + transform(lnError) + chr(13) + ;
				'Message: ' + laError[2] + chr(13) + ;
				iif(empty(lcSource), '', 'Code: ' + lcSource + chr(13)) + ;
				iif(lnLine = 0, '', 'Line #: ' + transform(lnLine) + chr(13)) + ;
				'Method: ' + lcMethod
			if version(2) = 0
				lnChoice = messagebox(lcMessage + chr(13) + chr(13) + ;
					'Choose OK to continue or Cancel to cancel execution', 17, ;
					_VFP.Caption)
			else
				lnChoice = messagebox(lcMessage + chr(13) + chr(13) + ;
					'Choose Yes to display the debugger, No to continue ' + ;
					'without the debugger, or Cancel to cancel execution', 19, ;
					_VFP.Caption)
			endif version(2) = 0
			do case
				case lnChoice = 6
					lcReturn = 'Debug'
				case lnChoice = 2
					lcReturn = 'Cancel'
			endcase
		endif not empty(on('ERROR'))
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ 'Continue,Retry,Cancel,Debug', 'Continue', lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = 'Debug'
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = 'Retry'
				retry
		
		* Cancel execution.
		
			case lcReturn = 'Cancel'
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE release		&& Releases this object
		* Release the object. Note the avoidance of "with This" in this code to prevent
		* potential problems with dangling object references.
		
		if This.lRelease
			return
		endif This.lRelease
		This.Cleanup()
		release This
		
	ENDPROC

	PROTECTED PROCEDURE releasemembers		&& Releases all member objects
		* Release each member so our reference in it is nuked.
		
		local lnI, ;
			loControl
		for lnI = This.Count to 1 step -1
			loControl = This.Item(lnI)
			loControl.Release()
		next lnI
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfmenufunction AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: execute		&& Performs the action of a menu or toolbar function
		*p: lenabled		&& .T. if the menu or toolbar item is enabled
		*p: lnoexecute		&& .T. to use this implementation object for display (enabled and visible) but not execution
		*p: lvisible		&& .T. if the menu or toolbar item is visible
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	lenabled = .T.		&& .T. if the menu or toolbar item is enabled
	lnoexecute = .F.		&& .T. to use this implementation object for display (enabled and visible) but not execution
	lvisible = .T.		&& .T. if the menu or toolbar item is visible
	Name = "sfmenufunction"
	Width = 17
	_memberdata = <VFPData>
		<memberdata name="execute" type="method" display="Execute"/>
		<memberdata name="lvisible" type="property" display="lVisible"/>
		<memberdata name="lenabled" type="property" display="lEnabled"/>
		<memberdata name="lnoexecute" type="property" display="lNoExecute"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE execute		&& Performs the action of a menu or toolbar function
		* Abstract method
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfmrubar AS sfbar OF "sfmenu.vcx" 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	cmenuclauses = mru
	conclickcommand = This.oParent.MRUSelected()
	Name = "sfmrubar"

ENDDEFINE

DEFINE CLASS sfpad AS sfmenubase OF "sfmenu.vcx" 		&& A pad in a menu
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addbar		&& Adds a bar to the popup for this pad
		*m: addbars		&& Add bars to the popup attached to this pad
		*m: addseparatorbar		&& Adds a separator bar to the menu
		*m: adjustseparators		&& Adjusts the separator bars so there aren't two consecutive nor is one at the top or bottom of the menu
		*m: define		&& Defines the pad
		*m: definepad		&& Define the pad
		*m: definepopup		&& Defines the popup for the pad
		*m: hide		&& Hide the pad
		*m: lvisible_assign
		*m: mruselected		&& Called when the MRU bar is clicked
		*m: onpad		&& Called from DefinePad to define what to do when the pad is selected
		*m: refresh		&& Refreshes the pad
		*m: show		&& Shows the pad
		*p: ccaption		&& The caption for the menu pad
		*p: cinstancename		&& The complete object path to this object starting from the menu object
		*p: ckey		&& The hotkey for the pad
		*p: cmrubarclass		&& The class to use for the MRU bar
		*p: cmrubarlibrary		&& The library containing the class specified in cMRUBarClass
		*p: cpadposition		&& Optional 'before' or 'after' pad clause to use in defining the pad's location on the menu
		*p: cpopupname		&& The name of the popup attached to this pad
		*p: cskipfor		&& The logical expression used for the SKIP FOR clause
		*p: cstatusbartext		&& Text displayed in the status bar when this pad is highlighted
		*p: ldefined		&& .T. if the pad and popup for this object have been defined
		*p: lmru		&& .T. to add an MRU bar at the bottom of the menu
		*p: lpaddefined		&& .T. if the pad has been defined
		*p: lvisible		&& .T. if the pad is visible
		*p: nseparatorbarcount		&& The number of separator bars in the menu
		*p: oparent		&& A reference to the parent for this pad
	*</DefinedPropArrayMethod>

	PROTECTED cpopupname,ldefined,lpaddefined,nseparatorbarcount
	ccaption = 		&& The caption for the menu pad
	cinstancename = 		&& The complete object path to this object starting from the menu object
	ckey = 		&& The hotkey for the pad
	cmrubarclass = SFMRUBar		&& The class to use for the MRU bar
	cmrubarlibrary = SFMenu.vcx		&& The library containing the class specified in cMRUBarClass
	cpadposition = 		&& Optional 'before' or 'after' pad clause to use in defining the pad's location on the menu
	cpopupname = 		&& The name of the popup attached to this pad
	cskipfor = 		&& The logical expression used for the SKIP FOR clause
	cstatusbartext = 		&& Text displayed in the status bar when this pad is highlighted
	ldefined = .F.		&& .T. if the pad and popup for this object have been defined
	lmru = .F.		&& .T. to add an MRU bar at the bottom of the menu
	lpaddefined = .F.		&& .T. if the pad has been defined
	lvisible = .T.		&& .T. if the pad is visible
	Name = "sfpad"
	nseparatorbarcount = 0		&& The number of separator bars in the menu
	oparent = .NULL.		&& A reference to the parent for this pad
	_memberdata = <VFPData>
		<memberdata name="addbar" type="method" display="AddBar"/>
		<memberdata name="addbars" type="method" display="AddBars" favorites="True"/>
		<memberdata name="addseparatorbar" type="method" display="AddSeparatorBar"/>
		<memberdata name="ccaption" type="property" display="cCaption" favorites="True"/>
		<memberdata name="cinstancename" type="property" display="cInstanceName"/>
		<memberdata name="ckey" type="property" display="cKey" favorites="True"/>
		<memberdata name="cmrubarclass" type="property" display="cMRUBarClass"/>
		<memberdata name="cmrubarlibrary" type="property" display="cMRUBarLibrary"/>
		<memberdata name="cpadposition" type="property" display="cPadPosition"/>
		<memberdata name="cpopupname" type="property" display="cPopupName"/>
		<memberdata name="cskipfor" type="property" display="cSkipFor" favorites="True"/>
		<memberdata name="cstatusbartext" type="property" display="cStatusBarText" favorites="True"/>
		<memberdata name="define" type="method" display="Define"/>
		<memberdata name="definepad" type="method" display="DefinePad"/>
		<memberdata name="definepopup" type="method" display="DefinePopup"/>
		<memberdata name="hide" type="method" display="Hide"/>
		<memberdata name="ldefined" type="property" display="lDefined"/>
		<memberdata name="lmru" type="property" display="lMRU" favorites="True"/>
		<memberdata name="lpaddefined" type="property" display="lPadDefined"/>
		<memberdata name="lvisible" type="property" display="lVisible"/>
		<memberdata name="lvisible_assign" type="method" display="lVisible_Assign"/>
		<memberdata name="mruselected" type="method" display="MRUSelected"/>
		<memberdata name="nseparatorbarcount" type="property" display="nSeparatorBarCount"/>
		<memberdata name="refresh" type="method" display="Refresh"/>
		<memberdata name="show" type="method" display="Show"/>
		<memberdata name="init" type="event" favorites="True"/>
		<memberdata name="oparent" type="property" display="oParent"/>
		<memberdata name="onpad" display="OnPad"/>
		<memberdata name="adjustseparators" display="AdjustSeparators"/>
		</VFPData>
	
	PROCEDURE addbar		&& Adds a bar to the popup for this pad
		lparameters tcClass, ;
			tcLibrary, ;
			tcName, ;
			tnBarNumber
		local lnBarNumber, ;
			llSpecified, ;
			loBar
		with This
		
		* Create a bar number if one wasn't passed.
		
			if vartype(tnBarNumber) = 'N' and tnBarNumber <> 0
				lnBarNumber = tnBarNumber
				llSpecified = .T.
			else
				lnBarNumber = .Count + 1
			endif vartype(tnBarNumber) = 'N' ...
		
		* Create the object as a member.
		
			if '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
				loBar = createobject(tcClass, lnBarNumber, .cPopupName, tcName, ;
					llSpecified)
			else
				loBar = newobject(tcClass, tcLibrary, '', lnBarNumber, .cPopupName, ;
					tcName, llSpecified)
			endif '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
			loBar.oParent = This
			.AddProperty(tcName, loBar)
		
		* Add the bar to the collection.
		
			.Add(loBar, tcName)
		endwith
		return loBar
		
	ENDPROC

	PROTECTED PROCEDURE addbars		&& Add bars to the popup attached to this pad
		* Abstract method
		
	ENDPROC

	PROCEDURE addseparatorbar		&& Adds a separator bar to the menu
		local lcName, ;
			loBar
		with This
			.nSeparatorBarCount = .nSeparatorBarCount + 1
			lcName = 'Separator' + transform(.nSeparatorBarCount)
			loBar  = .AddBar('SFSeparatorBar', 'SFMenu.vcx', lcName)
		endwith
		return loBar
		
	ENDPROC

	PROCEDURE adjustseparators		&& Adjusts the separator bars so there aren't two consecutive nor is one at the top or bottom of the menu
		local lnBefore, ;
			lnAfter, ;
			loSeparatorLast, ;
			loItem, ;
			llSeparator
		
		* There's nothing to do if there are no separators.
		
		if This.nSeparatorBarCount = 0
			return
		endif This.nSeparatorBarCount = 0
		
		* Go through the separators, setting lVisible = .F. for any that's out of
		* place.
		
		lnBefore        = 0
		lnAfter         = 0
		loSeparatorLast = .NULL.
		for each loItem in This
			llSeparator = lower(loItem.Class) = 'sfseparatorbar'
			do case
		
		* We have a separator and there aren't any bars before this one.
		
				case llSeparator and lnBefore = 0
					loItem.lVisible = .F.
		
		* We have a separator, so make it visible and reset the counts of before and
		* after items.
		
				case llSeparator
					loItem.lVisible = .T.
					loSeparatorLast = .NULL.
					lnBefore        = 0
					lnAfter         = 0
		
		* This is a visible non-separator, so increment the number of bars before
		* separators. If we have a previous separator, increment the bars after.
		
				case loItem.lVisible
					lnBefore = lnBefore + 1
					if vartype(loSeparatorLast) = 'O'
						lnAfter = lnAfter + 1
					endif vartype(loSeparatorLast) = 'O'
			endcase
		next loItem
		
		* If there are no after items, the last separator should be invisible as well.
		
		if lnAfter = 0 and vartype(loSeparatorLast) = 'O'
			loSeparatorLast.lVisible = .F.
		endif lnAfter = 0 ...
		
	ENDPROC

	PROTECTED PROCEDURE define		&& Defines the pad
		with This
		
		* Get the object path and the names of the pad, menu, and popup.
		
			.cInstanceName = .oParent.cInstanceName + '.' + .Name
		
		* Create a default status bar text if we don't have one.
		
			if empty(.cStatusBarText)
				.cStatusBarText = strtran(strtran(.cCaption, '\<'), '\')
			endif empty(.cStatusBarText)
		
		* Define the pad and popup if necessary, then add bars to the popup.
		
			if not .lPadDefined
				.DefinePopup()
				.DefinePad()
			endif not .lPadDefined
			.AddBars()
		
		* If this is an MRU menu, add an MRU bar at the end.
		
			if .lMRU
				.AddBar(.cMRUBarClass, .cMRUBarLibrary, 'MRUBar')
			endif .lMRU
		
		* Flag that the pad and popup have been defined.
		
			.lDefined = .T.
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE definepad		&& Define the pad
		* Define the pad.
		
		local lcObjectPath, ;
			lcPadName, ;
			lcPopupName, ;
			lcPosition, ;
			lcSkipFor, ;
			lcClauses
		with This
			lcObjectPath = .cInstanceName + '.'
			lcPadName    = .Name
			lcPopupName  = .cPopupName
			lcPosition   = alltrim(.cPadPosition)
		
		* Set the SKIP FOR for the pad.
		
			if empty(.cSkipFor)
				lcSkipFor = ''
			else
				lcSkipFor = 'skip for ' + strtran(.cSkipFor, 'This.', lcObjectPath)
			endif not empty(.cSkipFor)
		
		* Set the key clauses of the DEFINE PAD command.
		
			lcClauses = ''
			if not empty(.cKey)
				lcClauses = lcClauses + ' key ' + strtran(.cKey, '"', "'")
			endif not empty(.cKey)
		
		* Define the pad.
		
			define pad &lcPadName of (.oParent.cMenuName) prompt .cCaption ;
				color scheme 3 &lcPosition &lcSkipFor message .cStatusBarText ;
				negotiate left, right &lcClauses
			.OnPad(lcPadName, lcPopupName, lcObjectPath)
		
		* Flag that the pad has been defined.
		
			.lPadDefined = .T.
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE definepopup		&& Defines the popup for the pad
		define popup (This.cPopupName) margin relative shadow color scheme 4
		
	ENDPROC

	PROCEDURE hide		&& Hide the pad
		* Hide the pad by releasing it and its popup.
		
		local lcPadName, ;
			lcPopupName
		with This
			.lVisible    = .F.
			.lPadDefined = .F.
			lcPadName    = .Name
			lcPopupName = .cPopupName
			release pad &lcPadName of (.oParent.cMenuName)
			release popup &lcPopupName
		endwith
		
	ENDPROC

	PROCEDURE Init
		* Define the popup for this pad if it wasn't already.
		
		lparameters tcName
		with This
			if vartype(tcName) = 'C' and not empty(tcName)
				.Name = tcName
			endif vartype(tcName) = 'C' ...
			if empty(.cPopupName)
				.cPopupName = .Name
			endif empty(.cPopupName)
		endwith
		
	ENDPROC

	PROCEDURE lvisible_assign
		lparameters tlValue
		assert vartype(tlValue) = 'L'
		with This
			if tlValue <> .lVisible
				.lVisible = tlValue
				do case
					case .CalledFromThisClass()
					case tlValue
						.Show()
					otherwise
						.Hide()
				endcase
			endif tlValue <> .lVisible
		endwith
		
	ENDPROC

	PROCEDURE mruselected		&& Called when the MRU bar is clicked
		local lnI, ;
			loBar, ;
			lcPopupName
		with This
		
		* Hide the MRU bar, then show all inverted bars.
		
			.MRUBar.Hide()
			for lnI = 1 to .Count
				loBar = .Item(lnI)
				if loBar.lInvert
					loBar.Show()
				endif loBar.lInvert
			next lnI
		
		* Display the popup again.
		
			lcPopupName = .cPopupName
			activate popup &lcPopupName
		
		* Now that the popup is closed, show the MRU bar and hide all inverted bars.
		
			.MRUBar.Show()
			for lnI = 1 to .Count
				loBar = .Item(lnI)
				if loBar.lInvert
					loBar.Hide()
				endif loBar.lInvert
			next lnI
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE onpad		&& Called from DefinePad to define what to do when the pad is selected
		lparameters tcPadName, ;
			tcPopupName, ;
			tcObjectPath
		on pad &tcPadName of (This.oParent.cMenuName) activate popup &tcPopupName
		
	ENDPROC

	PROCEDURE refresh		&& Refreshes the pad
		* Refresh the pad by releasing and redefining the popup and refreshing each
		* bar.
		
		with This
			.Hide()
			.DefinePopup()
			.DefinePad()
			for lnI = 1 to .Count
				loBar = .Item(lnI)
				loBar.Refresh()
			next lnI
		endwith
		
	ENDPROC

	PROCEDURE releasemembers
		* Hide the pad and nuke our own parent reference.
		
		local lcPopupName, ;
			lnI, ;
			loBar
		This.Hide()
		lcPopupName = This.cPopupName
		if popup(lcPopupName)
			release popup &lcPopupName
		endif popup(lcPopupName)
		dodefault()
		This.oParent = .NULL.
		
	ENDPROC

	PROCEDURE show		&& Shows the pad
		* Define the popup and show all bars (except inverted bars, which must be
		* hidden).
		
		local lnI, ;
			loBar
		with This
			do case
		
		* If the pad has never been defined, call Define.
		
				case not .lDefined
					.Define()
		
		* If the pad has been defined but then released, call DefinePopup and
		* DefinePad.
		
				case not .lPadDefined
					.DefinePopup()
					.DefinePad()
			endcase
			for lnI = 1 to .Count
				loBar = .Item(lnI)
				if loBar.lInvert
					loBar.Hide()
				else
					loBar.Show()
				endif loBar.lInvert
			next lnI
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfpadcommand AS sfpad OF "sfmenu.vcx" 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: click		&& Called when the pad is chosen
		*m: oimplementation_assign
		*p: cactiveformmethod		&& The method of the active form to execute
		*p: cappobjectmethod		&& The method of the application object to execute
		*p: cappobjectname		&& The name of the variable containing the application object (only used if cAppObjectMethod is filled in)
		*p: conclickcommand		&& The command to execute when the bar is clicked
		*p: oimplementation		&& A reference to an implementation object
	*</DefinedPropArrayMethod>

	cactiveformmethod = 		&& The method of the active form to execute
	cappobjectmethod = 		&& The method of the application object to execute
	cappobjectname = oApp		&& The name of the variable containing the application object (only used if cAppObjectMethod is filled in)
	conclickcommand = 		&& The command to execute when the bar is clicked
	Name = "sfpadcommand"
	oimplementation = .NULL.		&& A reference to an implementation object
	_memberdata = <VFPData>
		<memberdata name="click" display="Click"/>
		<memberdata name="cactiveformmethod" display="cActiveFormMethod"/>
		<memberdata name="cappobjectmethod" display="cAppObjectMethod"/>
		<memberdata name="cappobjectname" display="cAppObjectName"/>
		<memberdata name="conclickcommand" display="cOnClickCommand"/>
		<memberdata name="oimplementation" display="oImplementation"/>
		<memberdata name="oimplementation_assign" display="oImplementation_Assign"/>
		</VFPData>
	
	PROCEDURE click		&& Called when the pad is chosen
		local lcMethod, ;
			lnPos, ;
			lcPadPath, ;
			lcBarPath, ;
			lcCommand
		with This
			do case
		
		* We have an implementation object and we're suppose to use it for execution,
		* so call its Execute method.
		
				case vartype(.oImplementation) = 'O' and ;
					not .oImplementation.lNoExecute
					.oImplementation.Execute()
		
		* If a method of the application object was specified, call it.
		
				case not empty(.cAppObjectMethod)
					lcMethod = .cAppObjectMethod
					lnPos    = at('(', lcMethod)
					if lnPos > 0
						lcMethod = left(lcMethod, lnPos - 1)
					endif lnPos > 0
					if type(.cAppObjectName + '.Name') = 'C' and ;
						pemstatus(evaluate(.cAppObjectName), lcMethod, 5)
						evaluate(.cAppObjectName + '.' + .cAppObjectMethod + ;
							iif(lnPos = 0, '()', ''))
					endif type(.cAppObjectName + '.Name') = 'C' ...
		
		* If a method of the active form was specified, call it.
		
				case not empty(.cActiveFormMethod)
					lcMethod = .cActiveFormMethod
					lnPos    = at('(', lcMethod)
					if lnPos > 0
						lcMethod = left(lcMethod, lnPos - 1)
					endif lnPos > 0
					if type('_screen.ActiveForm.Name') = 'C' and ;
						pemstatus(_screen.ActiveForm, lcMethod, 5)
						evaluate('_screen.ActiveForm.' + .cActiveFormMethod + ;
							iif(lnPos = 0, '()', ''))
					endif type('_screen.ActiveForm.Name') = 'C' ...
		
		* If an command to execute was specified, call it.
		
				case not empty(.cOnClickCommand)
					lcPadPath = .oParent.cInstanceName + '.'
					lcBarPath = lcPadPath + .Name + '.'
					lcCommand = strtran(strtran(.cOnClickCommand, 'This.oParent.', ;
						lcPadPath), 'This.', lcBarPath)
					if chr(13) $ lcCommand
						execscript(lcCommand)
					else
						&lcCommand
					endif chr(13) $ lcCommand
			endcase
		endwith
		
	ENDPROC

	PROCEDURE oimplementation_assign
		* Set a reference to an implementation object and bind to changes to its
		* lVisible and lEnabled properties.
		
		lparameters toObject
		if vartype(toObject) = 'O'
			This.oImplementation = toObject
			bindevent(This.oImplementation, 'lVisible', This, 'SetVisible', 1)
			bindevent(This.oImplementation, 'lEnabled', This, 'SetEnabled', 1)
		endif vartype(toObject) = 'O'
		
	ENDPROC

	PROCEDURE onpad
		lparameters tcPadName, ;
			tcPopupName, ;
			tcObjectPath
		on selection pad &tcPadName of (This.oParent.cMenuName) &tcObjectPath.Click()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfseparatorbar AS sfbar OF "sfmenu.vcx" 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	ccaption = \-
	Name = "sfseparatorbar"

ENDDEFINE
